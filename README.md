# Hi there, I'm Hackoverride ðŸ‘‹

*A great solution fades into the background, letting users focus solely on their goals, not the system.*

I love solving complex problems with Easy to Understand, Simple and Efficient solutions.

I identify as code-agnostic but if I had to pick my go-to languages, here they are:

```mermaid
  graph TD;
      A[hackOverride]-->B[Cloud Architecture];
      A-->D[Backend];
      A-->E[Frontend];
      A-->C[Big Data & IoT];
      A-->M[AI-ML]
      M-->O[Python]

      B-->K[Azure];

      C-->F[DataLake];

      D-->G[.NET];
      D-->H[Go];
      D-->I[Node];

      E-->J[React];
```

I do .NET C# for Enterprise, Go for Concurrency and Speed, Node for Simple applications, WebSockets and MVPs. Python for anything statistical or Math related.
Rust for anything where you have more time but need one part of a system that handles safe and fast transactions or calculations.

> I believe that one should always pick the right tool for the job. Even if it is a Monolithic approach or Loosely coupled microservice-architectured solution.
> The tools as in a language, framework, or any 3rd party solution, should always consider the possible *Risks* and *Future Technical Debt* as well as the resources currently and in the future.

Frontend I do Vanilla, React, Vue, or Angular but I find React and the components to be easiest to work with over many different projects. I tend to like Atomic Design patterns with SCSS/SASS.
Persistance? For Databases I have completed professional projects with Data Lake (parquet), MongoDB (MultiTenant), MySQL / PostgreSQL (Vectors), and a few other variations. 

## My programming mantra

> "The best programs are written so that computing machines can perform them quickly, and human beings can understand them clearly."
> *Donald Knuth*
